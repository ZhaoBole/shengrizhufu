<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <title>ç”Ÿæ—¥å¿«ä¹</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; overflow: hidden; background: #000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, PingFangSC, "Microsoft YaHei", sans-serif; }
    #app { position: relative; width: 100vw; height: 100vh; }
    #canvas-container { position: absolute; inset: 0; }
    
    /* éŸ³ä¹æ’­æ”¾æç¤ºå±‚ */
    .music-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      z-index: 100;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      transition: opacity 0.8s ease, visibility 0.8s ease;
      cursor: pointer;
    }
    
    .music-overlay.hidden {
      opacity: 0;
      visibility: hidden;
    }
    
    .music-icon {
      font-size: 48px;
      margin-bottom: 20px;
      animation: pulse 2s infinite;
      filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
    }
    
    .music-prompt {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 10px;
      text-align: center;
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    
    .music-subtitle {
      font-size: 16px;
      opacity: 0.8;
      text-align: center;
      max-width: 80%;
      line-height: 1.5;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    .barrage { position: fixed; inset: 0; pointer-events: none; z-index: 9; }
    .barrage-item { position: fixed; left: 100vw; white-space: nowrap; font-weight: 700; text-shadow: 0 0 8px rgba(255,255,255,0.35), 0 0 16px rgba(255,255,255,0.2); filter: drop-shadow(0 2px 4px rgba(0,0,0,0.35)); animation-name: fly; animation-timing-function: linear; animation-fill-mode: forwards; }
    @keyframes fly { 0% { transform: translateX(0); } 100% { transform: translateX(-120vw); } }
    .fullscreen-btn { position: fixed; right: 14px; bottom: 14px; z-index: 11; padding: 10px 14px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.12); color: #fff; font-weight: 600; letter-spacing: 0.5px; backdrop-filter: blur(4px); cursor: pointer; }
    .fullscreen-btn:hover { background: rgba(255,255,255,0.18); }
    @media (max-width: 768px) { 
      .fullscreen-btn { padding: 9px 12px; right: 10px; bottom: 10px; font-size: 13px; } 
      .music-icon { font-size: 36px; }
      .music-prompt { font-size: 18px; }
      .music-subtitle { font-size: 14px; }
    }
    @media (max-width: 768px) { .barrage-item { font-size: clamp(14px, 3.5vw, 20px); } }
    @media (min-width: 769px) { .barrage-item { font-size: clamp(16px, 2.1vw, 28px); } }
    
    /* éšè—éŸ³é¢‘æ§ä»¶ */
    audio {
      display: none;
    }
  </style>
</head>
<body>
  <!-- èƒŒæ™¯éŸ³ä¹ -->
  <audio id="bgMusic" loop>
    <source src="https://cdn.jsdelivr.net/gh/ZhaoBole/music@main/å¿ƒåšdj.m4a" type="audio/mp4">
  </audio>
  
  <!-- éŸ³ä¹æ’­æ”¾æç¤ºå±‚ -->
  <div id="musicOverlay" class="music-overlay">
    <div class="music-icon">ğŸµ</div>
    <div class="music-prompt">ç‚¹å‡»ç½‘é¡µä»»æ„ä½ç½®å¼€å§‹</div>
    <div class="music-subtitle">ç‹è‹¥é›¯ï¼Œç”Ÿæ—¥å¿«ä¹ï¼</div>
  </div>
  
  <div id="app"></div>
  <script type="module">
    import { createApp, ref, onMounted, h } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js';
    import * as THREE from 'https://unpkg.com/three@0.164.1/build/three.module.js';

    const App = {
      setup() {
        const isFs = ref(false);
        const barrageItems = ref([]);
        const containerEl = ref(null);

        let renderer, scene, camera, group;
        let pointsLeaves, pointsOrnaments, pointsStar, pointsAccents;
        let snowGroup, snowSprites, snowVel, snowRot, snowScale, snowOpacityPhase;
        let startTime = 0;
        const disperseDuration = 3500;
        const morphDuration = 3000;
        const particleCountLeaves = 5400;
        const particleCountOrnaments = 400;
        const particleCountStar = 320;
        const particleCountAccents = 160;
        const snowCount = 200;
        const baseRadius = 6.2;
        let running = true;
        const topY = 8.7; // è›‹ç³•é¡¶éƒ¨é«˜åº¦
        const bottomY = -1.4;

        // ç”Ÿæ—¥ç¥ç¦è¯
        const messages = [
          'ç”Ÿæ—¥å¿«ä¹', 'å¤©å¤©å¼€å¿ƒ', 'å¿ƒæƒ³äº‹æˆ', 'ä¸‡äº‹å¦‚æ„', 'é’æ˜¥æ°¸é©»', 'ç¬‘å£å¸¸å¼€',
          'å¹¸ç¦ç¾æ»¡', 'å¥åº·é•¿å¯¿', 'äº‹ä¸šæœ‰æˆ', 'é˜–å®¶æ¬¢ä¹', 'å¥½è¿è¿è¿', 'æ¢¦æƒ³æˆçœŸ'
        ];

        function randomHsl() {
          const h = Math.floor(Math.random() * 360);
          const s = 68 + Math.random() * 22;
          const l = 50 + Math.random() * 10;
          return `hsl(${h}deg, ${s}%, ${l}%)`;
        }

        function createSnowflakeTexture() {
          const c = document.createElement('canvas');
          c.width = 128; c.height = 128;
          const ctx = c.getContext('2d');
          ctx.clearRect(0, 0, 128, 128);
          ctx.translate(64, 64);
          ctx.strokeStyle = 'rgba(255,255,255,0.95)';
          ctx.lineWidth = 2;
          for (let i = 0; i < 6; i++) {
            const ang = (Math.PI * 2 / 6) * i;
            const x = Math.cos(ang) * 48;
            const y = Math.sin(ang) * 48;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(x, y);
            ctx.stroke();
            for (let b = 1; b <= 3; b++) {
              const t = b / 4;
              const bx = Math.cos(ang) * 48 * t;
              const by = Math.sin(ang) * 48 * t;
              const sideAng = ang + Math.PI / 2;
              const len = 10 * (1 - t);
              ctx.beginPath();
              ctx.moveTo(bx, by);
              ctx.lineTo(bx + Math.cos(sideAng) * len, by + Math.sin(sideAng) * len);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(bx, by);
              ctx.lineTo(bx - Math.cos(sideAng) * len, by - Math.sin(sideAng) * len);
              ctx.stroke();
            }
          }
          const tex = new THREE.CanvasTexture(c);
          tex.minFilter = THREE.LinearMipmapLinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.needsUpdate = true;
          return tex;
        }

        function createSnowGlowTexture() {
          const c = document.createElement('canvas');
          c.width = 128; c.height = 128;
          const ctx = c.getContext('2d');
          const grd = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
          grd.addColorStop(0, 'rgba(255,255,255,0.57)');
          grd.addColorStop(0.4, 'rgba(255,255,255,0.23)');
          grd.addColorStop(1, 'rgba(255,255,255,0.0)');
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
          const tex = new THREE.CanvasTexture(c);
          tex.minFilter = THREE.LinearMipmapLinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.needsUpdate = true;
          return tex;
        }

        function spawnBarrage() {
          const count = 2 + Math.floor(Math.random() * 3);
          const now = Date.now();
          for (let i = 0; i < count; i++) {
            const text = messages[Math.floor(Math.random() * messages.length)];
            const top = Math.random() * 90 + 5;
            const duration = 10 + Math.random() * 8;
            const color = randomHsl();
            const id = `${now}-${i}-${Math.random().toString(36).slice(2,7)}`;
            barrageItems.value.push({ id, text, top: `${top}%`, duration: `${duration}s`, color, shadow: color });
            setTimeout(() => {
              const idx = barrageItems.value.findIndex(x => x.id === id);
              if (idx >= 0) barrageItems.value.splice(idx, 1);
            }, duration * 1000 + 400);
          }
        }

        function toggleFs() { 
          if (document.fullscreenElement) document.exitFullscreen();
          else document.documentElement.requestFullscreen();
        }

        // è›‹ç³•å±‚ä½ç½®è®¡ç®—
        function computeLeafTargets(count) {
          const arr = new Float32Array(count * 3);
          const layers = 3;
          const layerHeight = 2.5;
          const gap = 0.5;
          
          for (let i = 0; i < count; i++) {
            const layer = Math.floor(Math.random() * layers);
            const yBase = layer * (layerHeight + gap);
            const y = yBase + (Math.random() * layerHeight);
            const t = layer / (layers - 1);
            const radius = baseRadius * (1 - t * 0.3);
            const wobble = 0.2 * Math.sin(8 * t + Math.random());
            const r = Math.max(0.5, radius + wobble);
            const a = Math.random() * Math.PI * 2;
            arr[i*3] = r * Math.cos(a);
            arr[i*3+1] = y;
            arr[i*3+2] = r * Math.sin(a);
          }
          return arr;
        }

        // è›‹ç³•è£…é¥°ä½ç½®è®¡ç®—
        function computeOrnamentTargets(count) {
          const arr = new Float32Array(count * 3);
          const layers = 3;
          const layerHeight = 2.5;
          const gap = 0.5;
          
          for (let i = 0; i < count; i++) {
            const layer = Math.floor(Math.random() * layers);
            const yBase = layer * (layerHeight + gap) + 0.5;
            const y = yBase + (Math.random() * 1.5);
            const t = layer / (layers - 1);
            const radius = baseRadius * (1 - t * 0.3) - 0.3;
            const wobble = 0.3 * Math.sin(8 * t + Math.random());
            const r = Math.max(0.5, radius + wobble);
            const a = Math.random() * Math.PI * 2;
            arr[i*3] = r * Math.cos(a);
            arr[i*3+1] = y;
            arr[i*3+2] = r * Math.sin(a);
          }
          return arr;
        }

        // èœ¡çƒ›ä½ç½®è®¡ç®—
        function computeStarTargets(count) {
          const arr = new Float32Array(count * 3);
          const layers = 3;
          const layerHeight = 2.5;
          const gap = 0.5;
          const candlesPerLayer = [3, 4, 5];
          let index = 0;
          
          for (let layer = 0; layer < layers; layer++) {
            const yBase = layer * (layerHeight + gap) + 0.2;
            const radius = baseRadius * (1 - layer * 0.3) - 0.3;
            const candleCount = candlesPerLayer[layer];
            
            for (let c = 0; c < candleCount; c++) {
              if (index >= count) break;
              const a = (c / candleCount) * Math.PI * 2;
              arr[index*3] = radius * Math.cos(a);
              arr[index*3+1] = yBase;
              arr[index*3+2] = radius * Math.sin(a);
              index++;
            }
          }
          return arr;
        }

        // ç³–éœœä½ç½®è®¡ç®—
        function computeAccentsTargets(count) {
          const arr = new Float32Array(count * 3);
          const layers = 3;
          const layerHeight = 2.5;
          const gap = 0.5;
          
          for (let i = 0; i < count; i++) {
            const layer = Math.floor(Math.random() * layers);
            const yBase = layer * (layerHeight + gap) + 2.3;
            const y = yBase - 0.1 + (Math.random() * 0.2);
            const t = layer / (layers - 1);
            const radius = baseRadius * (1 - t * 0.3) + 0.2;
            const wobble = 0.2 * Math.sin(8 * t + Math.random());
            const r = Math.max(0.5, radius + wobble);
            const a = Math.random() * Math.PI * 2;
            arr[i*3] = r * Math.cos(a);
            arr[i*3+1] = y;
            arr[i*3+2] = r * Math.sin(a);
          }
          return arr;
        }

        function easeInOutCubic(t) {
          return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // è£…é¥°çƒé¢œè‰²
        function ornamentColors(index) {
          const palette = [
            new THREE.Color(0xff4d6d), // ç²‰è‰²
            new THREE.Color(0xffb703), // é»„è‰²
            new THREE.Color(0x32c3ff), // è“è‰²
            new THREE.Color(0x8ce99a), // ç»¿è‰²
            new THREE.Color(0xb197fc), // ç´«è‰²
            new THREE.Color(0xffaad4)  // æµ…ç²‰
          ];
          return palette[index % palette.length];
        }

        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        function createParticleSystem(count, size, colorFn, computeTargets) {
          const geo = new THREE.BufferGeometry();
          const pos = new Float32Array(count * 3);
          const col = new Float32Array(count * 3);
          const vel = new Float32Array(count * 3);
          
          for (let i = 0; i < count; i++) {
            const ix = i * 3;
            pos[ix] = (Math.random() - 0.5) * 0.4;
            pos[ix+1] = (Math.random() - 0.5) * 0.4;
            pos[ix+2] = (Math.random() - 0.5) * 0.4;
            
            vel[ix] = (Math.random() - 0.5) * 0.012;
            vel[ix+1] = (Math.random() - 0.5) * 0.0072;
            vel[ix+2] = (Math.random() - 0.5) * 0.012;
            
            const c = colorFn(i);
            col[ix] = c.r;
            col[ix+1] = c.g;
            col[ix+2] = c.b;
          }
          
          geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
          geo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
          
          const mat = new THREE.PointsMaterial({
            size,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.95,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
          });
          
          const points = new THREE.Points(geo, mat);
          points.userData = {
            targets: computeTargets(count),
            startPositions: null,
            velocities: vel
          };
          
          group.add(points);
          return points;
        }

        function initThree() {
          scene = new THREE.Scene();
          scene.fog = new THREE.FogExp2(0x06101a, 0.035);
          
          camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
          camera.position.set(0, 4, 20);
          
          renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.outputColorSpace = THREE.SRGBColorSpace;
          containerEl.value.appendChild(renderer.domElement);

          group = new THREE.Group();
          scene.add(group);

          // ç¯å¢ƒå…‰
          const ambient = new THREE.AmbientLight(0xffffff, 0.35);
          scene.add(ambient);
          
          // ç‚¹å…‰æº
          const point = new THREE.PointLight(0xfff3e0, 3.2, 100);
          point.position.set(4, 6, 6);
          scene.add(point);
          
          // è›‹ç³•å±‚ï¼ˆå¶å­ï¼‰
          pointsLeaves = createParticleSystem(
            particleCountLeaves,
            0.12,
            (i) => {
              const colors = [
                new THREE.Color(0xffecb3), // æµ…é»„
                new THREE.Color(0xffccbc), // æµ…æ©™
                new THREE.Color(0xc5e1a5)  // æµ…ç»¿
              ];
              return colors[Math.floor(Math.random() * colors.length)];
            },
            computeLeafTargets
          );
          
          // è›‹ç³•è£…é¥°ï¼ˆè£…é¥°çƒï¼‰
          pointsOrnaments = createParticleSystem(
            particleCountOrnaments,
            0.14,
            ornamentColors,
            computeOrnamentTargets
          );
          
          // èœ¡çƒ›
          pointsStar = createParticleSystem(
            particleCountStar,
            0.12,
            () => new THREE.Color(0x7b1fa2), // ç´«è‰²èœ¡çƒ›
            computeStarTargets
          );
          
          // ç³–éœœ
          pointsAccents = createParticleSystem(
            particleCountAccents,
            0.22,
            () => new THREE.Color(0xffffff), // ç™½è‰²ç³–éœœ
            computeAccentsTargets
          );

          // é›ªèŠ±æ•ˆæœ
          const snowTex = createSnowflakeTexture();
          const glowTex = createSnowGlowTexture();
          snowGroup = new THREE.Group();
          snowGroup.renderOrder = 0;
          scene.add(snowGroup);
          
          snowSprites = [];
          snowVel = new Float32Array(snowCount * 2);
          snowRot = new Float32Array(snowCount);
          snowScale = new Float32Array(snowCount);
          snowOpacityPhase = new Float32Array(snowCount);
          
          for (let i = 0; i < snowCount; i++) {
            const mat = new THREE.SpriteMaterial({ 
              map: snowTex, 
              color: 0xffffff, 
              transparent: true, 
              opacity: 1.0, 
              depthWrite: false, 
              depthTest: false, 
              blending: THREE.AdditiveBlending, 
              fog: false 
            });
            
            const spr = new THREE.Sprite(mat);
            const s = (1.6 + Math.random() * 1.6) * (2/3);
            spr.scale.set(s, s, 1);
            
            spr.position.set(
              (Math.random() - 0.5) * 120,
              20 + Math.random() * 40,
              -22 - Math.random() * 12
            );
            
            snowScale[i] = s;
            snowVel[i*2] = (Math.random() - 0.5) * 0.006;
            snowVel[i*2+1] = -0.008 - Math.random() * 0.01;
            snowRot[i] = (-0.004 + Math.random() * 0.008);
            snowOpacityPhase[i] = Math.random() * Math.PI * 2;
            snowSprites.push(spr);
            snowGroup.add(spr);
            
            // é›ªèŠ±å…‰æ™•
            const haloMat = new THREE.SpriteMaterial({ 
              map: glowTex, 
              color: 0xffffff, 
              transparent: true, 
              opacity: 0.6, 
              depthWrite: false, 
              depthTest: false, 
              blending: THREE.AdditiveBlending, 
              fog: false 
            });
            
            const halo = new THREE.Sprite(haloMat);
            halo.scale.set(s * 2.6, s * 2.6, 1);
            halo.position.copy(spr.position);
            snowGroup.add(halo);
          }
          
          // è®¾ç½®æ¸²æŸ“é¡ºåº
          pointsLeaves.renderOrder = 1;
          pointsOrnaments.renderOrder = 1;
          pointsStar.renderOrder = 1;
          pointsAccents.renderOrder = 1;
          
          fitCamera();
          startTime = performance.now();
          animate();
          window.addEventListener('resize', onResize);
        }

        function animate() {
          if (!running) return;
          
          const now = performance.now();
          const elapsed = now - startTime;
          const dt = 16;
          
          // æ›´æ–°é›ªèŠ±
          for (let i = 0; i < snowCount; i++) {
            const spr = snowSprites[i];
            spr.position.x += snowVel[i*2] * dt;
            spr.position.y += snowVel[i*2+1] * dt;
            spr.material.rotation += snowRot[i];
            
            const f = Math.min(1.0, 0.9 + 0.45 * Math.abs(Math.sin(now * 0.0015 + snowOpacityPhase[i])));
            spr.material.opacity = 0.67 * f;
            
            const halo = snowGroup.children[i*2 + 1];
            if (halo) {
              halo.position.copy(spr.position);
              halo.material.opacity = Math.min(1.0, 0.47 * f);
            }
            
            if (spr.position.y < -30) {
              spr.position.set(
                (Math.random() - 0.5) * 120,
                20 + Math.random() * 40,
                -22 - Math.random() * 12
              );
              spr.material.rotation = Math.random() * Math.PI * 2;
              if (halo) halo.position.copy(spr.position);
            }
          }

          // æ›´æ–°ç²’å­ç³»ç»Ÿ
          [pointsLeaves, pointsOrnaments, pointsStar, pointsAccents].forEach(points => {
            const geo = points.geometry;
            const arr = geo.attributes.position.array;
            const data = points.userData;
            const count = arr.length / 3;
            
            if (elapsed < disperseDuration) {
              // åˆ†æ•£é˜¶æ®µ
              for (let i = 0; i < count; i++) {
                const ix = i * 3;
                arr[ix] += data.velocities[ix] * dt;
                arr[ix+1] += data.velocities[ix+1] * dt;
                arr[ix+2] += data.velocities[ix+2] * dt;
              }
            } else {
              // å˜å½¢é˜¶æ®µ
              if (!data.startPositions) {
                data.startPositions = new Float32Array(arr);
              }
              
              const t = Math.min(1, (elapsed - disperseDuration) / morphDuration);
              const e = easeInOutCubic(t);
              
              for (let i = 0; i < count; i++) {
                const ix = i * 3;
                const target = data.targets;
                arr[ix] = data.startPositions[ix] + (target[ix] - data.startPositions[ix]) * e;
                arr[ix+1] = data.startPositions[ix+1] + (target[ix+1] - data.startPositions[ix+1]) * e;
                arr[ix+2] = data.startPositions[ix+2] + (target[ix+2] - data.startPositions[ix+2]) * e;
              }
            }
            
            geo.attributes.position.needsUpdate = true;
          });

          group.rotation.y += 0.0032;
          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }

        function onResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          fitCamera();
        }

        function fitCamera() {
          const aspect = camera.aspect;
          const vfov = THREE.MathUtils.degToRad(camera.fov);
          const halfH = (topY - bottomY) * 0.5 * 1.06;
          const radNeeded = (baseRadius + 1.6) * 1.06;
          const zH = halfH / Math.tan(vfov / 2);
          const zW = radNeeded / (Math.tan(vfov / 2) * aspect);
          const z = Math.max(zH, zW, 20);
          
          camera.position.z = z;
          camera.position.y = (topY + bottomY) * 0.5;
          camera.lookAt(0, (topY + bottomY) * 0.5, 0);
        }

        // å¼€å§‹æ’­æ”¾éŸ³ä¹
        function startMusic() {
          const bgMusic = document.getElementById('bgMusic');
          const overlay = document.getElementById('musicOverlay');
          
          // æ’­æ”¾éŸ³ä¹
          bgMusic.play().then(() => {
            console.log("éŸ³ä¹å¼€å§‹æ’­æ”¾");
          }).catch(e => {
            console.log("éŸ³ä¹æ’­æ”¾å¤±è´¥:", e);
          });
          
          // éšè—æç¤ºå±‚
          overlay.classList.add('hidden');
          
          // ç§»é™¤ç‚¹å‡»äº‹ä»¶ï¼Œé¿å…é‡å¤è§¦å‘
          setTimeout(() => {
            overlay.style.display = 'none';
          }, 800);
        }

        onMounted(() => {
          const el = document.createElement('div');
          el.id = 'canvas-container';
          document.getElementById('app').appendChild(el);
          containerEl.value = el;
          initThree();
          setInterval(spawnBarrage, 1200);
          document.addEventListener('fullscreenchange', () => { isFs.value = !!document.fullscreenElement; });
          
          // æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬
          const overlay = document.getElementById('musicOverlay');
          overlay.addEventListener('click', startMusic);
          
          // å…è®¸ç”¨æˆ·ç‚¹å‡»é¡µé¢ä»»æ„ä½ç½®å¼€å§‹æ’­æ”¾
          document.addEventListener('click', function startOnAnyClick(e) {
            // å¦‚æœç‚¹å‡»çš„ä¸æ˜¯å…¨å±æŒ‰é’®
            if (!e.target.closest('.fullscreen-btn')) {
              startMusic();
              // ç§»é™¤äº‹ä»¶ç›‘å¬ï¼Œé¿å…é‡å¤è§¦å‘
              document.removeEventListener('click', startOnAnyClick);
            }
          });
        });

        return () => h('div', { style: { width: '100%', height: '100%' } }, [
          h('div', { class: 'barrage' }, barrageItems.value.map(item => 
            h('div', {
              key: item.id,
              class: 'barrage-item',
              style: {
                top: item.top,
                color: item.color,
                animationDuration: item.duration,
              }
            }, item.text)
          )),
          h('button', { class: 'fullscreen-btn', onClick: toggleFs }, 
            isFs.value ? 'é€€å‡ºå…¨å±' : 'å…¨å±'
          )
        ]);
      }
    };

    createApp(App).mount('#app');
  </script>
</body>
</html>